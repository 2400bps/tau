package rng

import (
	"fmt"
	"time"

	"github.com/republicprotocol/oro-go/core/vss"
	"github.com/republicprotocol/oro-go/core/vss/shamir"
)

// ShareMap is a convenience type that associates addresses with shares.
type ShareMap map[Address]vss.VShare

// A Nominate message is used to nominate a computation leader. The Leader
// Address is the address of the nominated leader.
type Nominate struct {
	Leader Address
}

// NewNominate creates a new Nominate message.
func NewNominate(addr Address) Nominate {
	return Nominate{
		addr,
	}
}

// IsMessage implements the Message interface.
func (message Nominate) IsMessage() {
}

func (message Nominate) String() string {
	return fmt.Sprintf("rng.Nominate {\n\tleader: %v\n}", message.Leader)
}

// A GenerateRn message signals to the Rnger that is should begin a secure
// random number generation. The secure random number that will be generated is
// identified by a nonce. The nonce must be unique and must be agreed on by all
// Rngers in the network. After receiving this message, an Rnger will produce a
// LocalRnShare for all Rngers in the network. The user must route these
// LocalRnShare messages to their respective Rngers.
type GenerateRn struct {
	Nonce
}

// NewGenerateRn creates a new GenerateRn message.
func NewGenerateRn(nonce Nonce) GenerateRn {
	return GenerateRn{
		nonce,
	}
}

// IsMessage implements the Message interface.
func (message GenerateRn) IsMessage() {
}

func (message GenerateRn) String() string {
	return fmt.Sprintf("rng.GenerateRn {\n\tnonce: %v\n}", message.Nonce)
}

// A ProposeRn message is sent by a computation leader to the compute nodes. It
// is a proposal by the computation leader for the compute nodes to generate a
// local random number which will then be shared to eventually produce a global
// shared random number. This message is sent once the nominated leader has
// received a GenerateRn message.
type ProposeRn struct {
	Nonce

	To   Address
	From Address
}

// NewProposeRn creates a new ProposeRn message.
func NewProposeRn(nonce Nonce, to, from Address) ProposeRn {
	return ProposeRn{
		nonce,
		to,
		from,
	}
}

// IsMessage implements the Message interface.
func (message ProposeRn) IsMessage() {
}

func (message ProposeRn) String() string {
	return fmt.Sprintf("rng.ProposeRn {\n\tnonce: %v\n\tto: %v\n\tfrom: %v\n}", message.Nonce, message.To, message.From)
}

// A LocalRnShares message is produced by an Rnger after receiving a GenerateRn
// message. A LocalRnShares message will be produced for each Rnger in the
// network and it is up to the user to route this message to the appropriate
// Rnger. A LocalRnShares message can also be passed to an Rnger as input,
// representing the LocalRnShares messages sent to it by other Rngers in the
// network.
type LocalRnShares struct {
	Nonce

	To          Address
	From        Address
	RhoShares   ShareMap
	SigmaShares ShareMap
}

// NewLocalRnShares creates a new LocalRnShares message.
func NewLocalRnShares(nonce Nonce, to, from Address, rhoShares, sigmaShares map[Address]vss.VShare) LocalRnShares {
	return LocalRnShares{
		nonce,

		to,
		from,
		rhoShares,
		sigmaShares,
	}
}

// IsMessage implements the Message interface.
func (message LocalRnShares) IsMessage() {
}

func (message LocalRnShares) String() string {
	return fmt.Sprintf("rng.LocalRnShares {\n\tnonce: %v\n\tto: %v\n\tfrom: %v\n\trhoshares: %v\n\tsigmashares: %v\n}", message.Nonce, message.To, message.From, message.RhoShares, message.SigmaShares)
}

// A ProposeGlobalRnShare message is sent by the computation leader and contains
// shares of the local random numbers generated by a selection of the compute
// nodes. This message is sent to each compute node, which can then sum up the
// contained shares to produce a single share of a global random number.
type ProposeGlobalRnShare struct {
	Nonce

	To          Address
	From        Address
	RhoShares   ShareMap
	SigmaShares ShareMap
}

// NewProposeGlobalRnShare creates a new ProposeGlobalRnShare message.
func NewProposeGlobalRnShare(nonce Nonce, to, from Address, rhoShares, sigmaShares map[Address]vss.VShare) ProposeGlobalRnShare {
	return ProposeGlobalRnShare{
		nonce,
		to,
		from,
		rhoShares,
		sigmaShares,
	}
}

// IsMessage implements the Message interface.
func (message ProposeGlobalRnShare) IsMessage() {
}

func (message ProposeGlobalRnShare) String() string {
	return fmt.Sprintf("rng.ProposeGlobalRnShare {\n\tnonce: %v\n\tto: %v\n\tfrom: %v\n\trhoshares: %v\n\tsigmashares: %v\n}", message.Nonce, message.To, message.From, message.RhoShares, message.SigmaShares)
}

// A GlobalRnShare message is produced by an Rnger at the end of a successful
// secure random number generation. It is the Shamir's secret share of the
// secure random number that has been generated.
type GlobalRnShare struct {
	Nonce
	RhoShare   shamir.Share
	SigmaShare shamir.Share

	From Address
}

// NewGlobalRnShare creates a new GlobalRnShare message.
func NewGlobalRnShare(nonce Nonce, rhoShare, sigmaShare shamir.Share, from Address) GlobalRnShare {
	return GlobalRnShare{
		nonce,
		rhoShare,
		sigmaShare,
		from,
	}
}

// IsMessage implements the Message interface.
func (message GlobalRnShare) IsMessage() {
}

func (message GlobalRnShare) String() string {
	return fmt.Sprintf("rng.GlobalRnShare {\n\tnonce: %v\n\trhoshares: %v\n\tsigmashares: %v\n\tfrom: \n}", message.Nonce, message.RhoShare, message.SigmaShare, message.From)
}

// A VoteGlobalRnShare message is produced by an Rnger after receiving a sufficient number of
// LocalRnShares messages, or after a secure random number generation has
// exceeded its deadline. A VoteGlobalRnShare message will be produced for each Rnger in the
// network and it is up to the user to route this message to the appropriate
// Rnger.
type VoteGlobalRnShare struct {
	Nonce

	To      Address
	From    Address
	Players []Address
}

// NewVoteGlobalRnShare creates a new VoteGlobalRnShare message.
func NewVoteGlobalRnShare(nonce Nonce, to, from Address, players []Address) VoteGlobalRnShare {
	return VoteGlobalRnShare{
		nonce,

		to,
		from,
		players,
	}
}

// IsMessage implements the Message interface.
func (message VoteGlobalRnShare) IsMessage() {
}

func (message VoteGlobalRnShare) String() string {
	return fmt.Sprintf("rng.VoteGlobalRnShare {\n\tnonce: %v\n\trhoshares: %v\n\tsigmashares: %v\n\tfrom: \n}", message.Nonce, message.To, message.From, message.Players)
}

// A CheckDeadline message signals to the Rnger that it should clean up all
// pending random number generations that have exceeded their deadline. It is up
// to the user to determine the frequency of this message. Higher frequencies
// will result in more accurate clean up times, but slower performance.
type CheckDeadline struct {
	time.Time
}

// NewCheckDeadline creates a new CheckDeadline message.
func NewCheckDeadline(time time.Time) CheckDeadline {
	return CheckDeadline{
		time,
	}
}

// IsMessage implements the Message interface.
func (message CheckDeadline) IsMessage() {
}

func (message CheckDeadline) String() string {
	return fmt.Sprintf("rng.CheckDeadline {\n\ttime: %v\n}", message.Time)
}

// Err is a message that is sent by a player when they encounter an error during
// a random number generation.
type Err struct {
	Nonce
	error
}

// NewErr creates a new Err message.
func NewErr(nonce Nonce, err error) Err {
	return Err{
		nonce,
		err,
	}
}

// IsMessage implements the Message interface.
func (message Err) IsMessage() {
}

func (message Err) String() string {
	return fmt.Sprintf("rng.Err {\n\tnonce: %v\n\terror: %v\n}", message.Nonce, message.Error)
}
